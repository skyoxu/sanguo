# Task 3: 实现城池类

## 0. 映射与来源
- Mapping: `tasks.json.master.tasks[].id` (`"3"`) <-> `tasks_back[].taskmaster_id` <-> `tasks_gameplay[].taskmaster_id`
- 注意：`tasks.json` 的 `id` 是字符串，views 文件里是数字，做关联时需 `str()` 归一化，否则会出现“找不到关联”的假报错。

## 1. 任务元信息（从三份任务文件汇总）
- tasks.json: title=`实现城池类`, status=`pending`, priority=`high`, complexity=`5`
- tasks.json.details:
  - 创建City类，包含名称、所属州郡、基础价格、基础过路费等属性。实现计算当前价格和过路费的方法。
- tasks.json.testStrategy:
  - 通过单元测试验证城池属性的正确性和方法的输出。
  - Local demo paths: C:\buildgame\godotdemo\demo\godot-demo-projects\2d\hexagonal_map ; C:\buildgame\godotdemo\demo\godot-demo-projects\2d\dynamic_tilemap_layers ; C:\buildgame\godotdemo\dafuweng\monopoly_clone
- tasks.json.adrRefs=`['ADR-0005', 'ADR-0015', 'ADR-0018', 'ADR-0020', 'ADR-0021', 'ADR-0024', 'ADR-0025']`
- tasks.json.archRefs=`['CH01', 'CH04', 'CH05', 'CH06', 'CH07', 'CH09']`
- tasks.json.overlay=`docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md`
- tasks_back.json: layer=`core`, depends_on=`['SG-0002']`
  - adr_refs=`['ADR-0005', 'ADR-0015', 'ADR-0018', 'ADR-0020', 'ADR-0021', 'ADR-0024', 'ADR-0025']`
  - chapter_refs=`['CH01', 'CH04', 'CH05', 'CH06', 'CH07', 'CH09']`
  - overlay_refs=`['docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md']`
  - acceptance:
    - 核心玩法相关类与方法在 Game.Core 中实现且不依赖 Godot API。
    - 对应任务的 xUnit 测试用例存在并通过（见 test_refs 占位路径）。
    - 符合学习模块一（棋盘 / 城池 / 环形路线）的任务分解：在棋盘与场景结构上参考 Godot 官方演示项目 2d/hexagonal_map、2d/dynamic_tilemap_layers，只借鉴结构与模式，不直接复制代码。
    - Local demo references: C:\buildgame\godotdemo\demo\godot-demo-projects\2d\hexagonal_map ; C:\buildgame\godotdemo\demo\godot-demo-projects\2d\dynamic_tilemap_layers ; C:\buildgame\godotdemo\dafuweng\monopoly_clone
  - test_strategy:
    - 为核心玩法编写 xUnit + FluentAssertions 单元测试覆盖主要状态机与计算。
    - 使用覆盖率工具（coverlet）确保核心逻辑达到 ADR-0005 规定的门禁。
    - 在本项目实现前，先运行并阅读 2d/hexagonal_map 或相关 TileMap 演示项目，据此设计一组棋盘位置与移动路径的单元测试 / 场景测试，用于验证环形路线与城池状态更新逻辑。
    - Local demo paths for implementation/tests: C:\buildgame\godotdemo\demo\godot-demo-projects\2d\hexagonal_map ; C:\buildgame\godotdemo\demo\godot-demo-projects\2d\dynamic_tilemap_layers ; C:\buildgame\godotdemo\dafuweng\monopoly_clone
- tasks_gameplay.json: layer=`core`, depends_on=`['GM-0002']`
  - adr_refs=`['ADR-0005', 'ADR-0015', 'ADR-0018', 'ADR-0020', 'ADR-0021', 'ADR-0024', 'ADR-0025']`
  - chapter_refs=`['CH01', 'CH04', 'CH05', 'CH06', 'CH07', 'CH09']`
  - overlay_refs=`['docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md']`
  - acceptance:
    - 核心玩法相关类与方法在 Game.Core 中实现且不依赖 Godot API。
    - 对应任务的 xUnit 测试用例存在并通过（见 test_refs 占位路径）。
    - 符合学习模块一（棋盘 / 城池 / 环形路线）的任务分解：在棋盘与场景结构上参考 Godot 官方演示项目 2d/hexagonal_map、2d/dynamic_tilemap_layers，只借鉴结构与模式，不直接复制代码。
    - Local demo references: C:\buildgame\godotdemo\demo\godot-demo-projects\2d\hexagonal_map ; C:\buildgame\godotdemo\demo\godot-demo-projects\2d\dynamic_tilemap_layers ; C:\buildgame\godotdemo\dafuweng\monopoly_clone
  - test_strategy:
    - 为核心玩法编写 xUnit + FluentAssertions 单元测试覆盖主要状态机与计算。
    - 使用覆盖率工具（coverlet）确保核心逻辑达到 ADR-0005 规定的门禁。
    - 在本项目实现前，先运行并阅读 2d/hexagonal_map 或相关 TileMap 演示项目，据此设计一组棋盘位置与移动路径的单元测试 / 场景测试，用于验证环形路线与城池状态更新逻辑。
    - Local demo paths for implementation/tests: C:\buildgame\godotdemo\demo\godot-demo-projects\2d\hexagonal_map ; C:\buildgame\godotdemo\demo\godot-demo-projects\2d\dynamic_tilemap_layers ; C:\buildgame\godotdemo\dafuweng\monopoly_clone

## 2. Serena 检索结果（为实现准备上下文）
### 2.1 find_symbol：现有 City 相关类型
- 目前仓库中不存在可直接复用的 `City` / `SanguoCity` 领域类（实现层）。
- 但已经存在与城池强相关的 T2 事件契约（见 `Game.Core/Contracts/Sanguo/EconomyEvents.cs`），实现时应优先对齐这些契约，避免后续返工。

### 2.2 search_for_pattern：现有端口/接口（了解现有契约与发布方式）
- `Game.Core/Services/EventBus.cs`：`IEventBus`（Core 层发布/订阅 DomainEvent 的统一入口）
```csharp
public interface IEventBus
{
    Task PublishAsync(DomainEvent evt);
    IDisposable Subscribe(Func<DomainEvent, Task> handler);
}
```
- `Game.Core/Contracts/DomainEvent.cs`：当前 CloudEvents 风格事件载体（ADR-0004 口径）
```csharp
public record DomainEvent(
    string Type,
    string Source,
    IEventData? Data,
    DateTime Timestamp,
    string Id,
    string SpecVersion = "1.0",
    string DataContentType = "application/json"
);
```
- `Game.Core/Contracts/IEventData.cs` + `Game.Core/Contracts/JsonEventData.cs`：事件数据载体（已收紧到 `IEventData`，避免不受限 `object`）
```csharp
public interface IEventData
{
}

public sealed record RawJsonEventData(string Json) : IEventData;

public sealed record JsonElementEventData(JsonElement Value) : IEventData
{
    public static JsonElementEventData FromObject<T>(T value, JsonSerializerOptions? options = null)
        => new(JsonSerializer.SerializeToElement(value, options));
}
```

### 2.3 find_symbol：T2 事件契约（ADR-0004 命名与字段口径）
- `Game.Core/Contracts/Sanguo/EconomyEvents.cs`：
```csharp
public sealed record SanguoYearPriceAdjusted(
    string GameId,
    int Year,
    string CityId,
    decimal OldPrice,
    decimal NewPrice,
    DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.economy.year.price.adjusted";
}

public sealed record SanguoCityBought(
    string GameId,
    string BuyerId,
    string CityId,
    decimal Price,
    DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.city.bought";
}

public sealed record SanguoCityTollPaid(
    string GameId,
    string PayerId,
    string OwnerId,
    string CityId,
    decimal Amount,
    DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.city.toll.paid";
}
```
- `Game.Core/Contracts/Sanguo/PlayerAndAiEvents.cs`（城池相关结算最终往往体现为玩家状态变化）：
```csharp
public sealed record SanguoPlayerStateChanged(
    string GameId,
    string PlayerId,
    decimal Money,
    int PositionIndex,
    System.DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.player.state.changed";
}
```
- `Game.Core/Contracts/Sanguo/BoardEvents.cs`（城池触发点通常来自移动落点）：
```csharp
public sealed record SanguoTokenMoved(
    string GameId,
    string PlayerId,
    int FromIndex,
    int ToIndex,
    int Steps,
    bool PassedStart,
    System.DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.board.token.moved";
}
```

### 2.4 find_referencing_symbols：依赖引用（已有模块如何使用）
- `IEventBus` 已被 `GameEngineCore`、`CombatService`、`EventBusAdapter`（Godot 侧）与测试中的 `CapturingEventBus` 使用；后续若城池逻辑需要发布事件，可以直接沿用这些用法。
- `SanguoTokenMoved` 当前仅在 `Game.Core.Tests/Domain/SanguoContractsTests.cs` 中用于校验 `EventType`，尚未被业务逻辑发布/消费。
- `SanguoCityBought` / `SanguoCityTollPaid` / `SanguoYearPriceAdjusted` 目前没有引用点，说明它们是“先定契约、后落实现”的骨干，Task 3/后续任务实现时需要主动对齐。

## 3. 实现建议（止损视角）
- Task 3 的描述缺少“当前价格/过路费”的公式与输入（如：是否随年增长、是否随地区/季节事件波动、是否与持有次数/等级相关）。建议实现时把公式做成显式入参（例如 `year`/`multiplier`），避免隐藏读取全局状态导致测试脆弱。
- 建议把城池模型放在 `Game.Core/Domain/Sanguo/City.cs`（或 `Game.Core/Domain/Sanguo/City.cs`），避免与模板自带通用实体（`User`/`SaveGame`）混杂；属性类型优先沿用契约口径（`string CityId`, `string RegionId`, `decimal`）。
- 单元测试建议（后续落地）：至少覆盖 1) 属性初始化与约束（非空/非负）；2) 价格计算与过路费计算在边界条件（year=0/1、multiplier=0、极大值）下的行为。
