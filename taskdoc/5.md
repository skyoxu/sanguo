# Task 5: 实现骰子机制

## 0. 映射与来源
- Mapping: `tasks.json.master.tasks[].id` (`"5"`) <-> `tasks_back[].taskmaster_id` <-> `tasks_gameplay[].taskmaster_id`
- 注意：`tasks.json` 的 `id` 是字符串，`tasks_back.json`/`tasks_gameplay.json` 的 `taskmaster_id` 是数字；做关联映射时必须 `str()` 归一化。
- 注意：`tasks.json` 使用字段名 `dependencies`；`tasks_back.json`/`tasks_gameplay.json` 使用字段名 `depends_on`。

## 1. 任务元信息（从三份任务文件汇总）
- tasks.json: title=`实现骰子机制`, status=`in-progress`, priority=`medium`, complexity=`5`, dependencies=`['1']`
- tasks.json.details:
  - 使用随机数生成器实现骰子投掷，返回 1..6 的随机数。
- tasks.json.testStrategy（摘录要点）:
  - xUnit + FluentAssertions：掷骰结果始终在 1..6（含边界）。
  - 随机源可控：优先复用 `Game.Core/Utilities/RandomHelper.cs`；必要时允许注入随机源以便确定性测试。
  - 事件对齐（ADR-0004）：掷骰后发布 `SanguoDiceRolled`（`Game.Core/Contracts/Sanguo/BoardEvents.cs`），并验证 `DomainEvent.Type == SanguoDiceRolled.EventType` 且 payload 的 Value 与点数一致。
  - 覆盖率门禁：lines>=90%、branches>=85%（ADR-0005）。
- tasks.json.adrRefs=`['ADR-0005','ADR-0015','ADR-0018','ADR-0020','ADR-0021','ADR-0024','ADR-0025']`
- tasks.json.archRefs=`['CH01','CH04','CH05','CH06','CH07','CH09']`
- tasks.json.overlay=`docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md`

- tasks_back.json: id=`SG-0005`, layer=`core`, status=`pending`, priority=`P1`, depends_on=`['SG-0001']`
  - adr_refs=`['ADR-0005','ADR-0015','ADR-0018','ADR-0020','ADR-0021','ADR-0024','ADR-0025']`
  - chapter_refs=`['CH01','CH04','CH05','CH06','CH07','CH09']`
  - overlay_refs 包含：
    - `docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md`
    - `docs/architecture/overlays/PRD-SANGUO-T2/08/ACCEPTANCE_CHECKLIST.md`

- tasks_gameplay.json: id=`GM-0005`, layer=`core`, status=`pending`, priority=`P1`, depends_on=`['GM-0001']`
  - adr_refs/chapter_refs/overlay_refs 与 `tasks_back.json` 对齐（同口径增强说明）。

## 2. Serena 检索结果（为实现准备上下文）

### 2.1 find_symbol：现有随机源、事件契约与事件总线
- 现有随机源（可直接复用）：`Game.Core/Utilities/RandomHelper.cs`
```csharp
public static class RandomHelper
{
    private static readonly ThreadLocal<Random> _rng = new(() => new Random());

    public static int NextInt(int minInclusive, int maxExclusive)
        => _rng.Value!.Next(minInclusive, maxExclusive);
}
```

- 现有事件契约（不要新建同名/同义事件）：`Game.Core/Contracts/Sanguo/BoardEvents.cs`
```csharp
public sealed record SanguoDiceRolled(
    string GameId,
    string PlayerId,
    int Value,
    System.DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    public const string EventType = "core.sanguo.dice.rolled";
}
```

- 事件总线入口：`Game.Core/Services/EventBus.cs`
```csharp
public interface IEventBus
{
    Task PublishAsync(DomainEvent evt);
    IDisposable Subscribe(Func<DomainEvent, Task> handler);
}
```

- DomainEvent 信封（CloudEvents-like）：`Game.Core/Contracts/DomainEvent.cs`
```csharp
public record DomainEvent(
    string Type,
    string Source,
    IEventData? Data,
    DateTime Timestamp,
    string Id,
    string SpecVersion = "1.0",
    string DataContentType = "application/json"
);
```

- 安全 payload 包装（避免 object 注入）：`Game.Core/Contracts/JsonEventData.cs`
```csharp
public sealed record JsonElementEventData(JsonElement Value) : IEventData
{
    public static JsonElementEventData FromObject<T>(T value, JsonSerializerOptions? options = null)
        => new(JsonSerializer.SerializeToElement(value, options));
}
```

- Null-object 总线（用于强制依赖非空、避免静默降级）：`Game.Core/Services/NullEventBus.cs`

### 2.2 search_for_pattern：现有 DomainEvent 发布模式（可复用）
- `Game.Core/Engine/GameEngineCore.cs` 已封装了发布模式：
  - `JsonElementEventData.FromObject(...)` 作为 `Data`
  - `DateTime.UtcNow` 作为 `Timestamp`
  - `Guid.NewGuid().ToString("N")` 作为 `Id`
```csharp
private void Publish(string type, IEventData? data)
{
    _ = _bus.PublishAsync(new DomainEvent(
        type,
        nameof(GameEngineCore),
        data,
        DateTime.UtcNow,
        Guid.NewGuid().ToString("N")));
}
```

### 2.3 find_symbol：Sanguo 事件契约文件清单（避免重复造轮子）
- `Game.Core/Contracts/Sanguo/BoardEvents.cs`：棋子移动、掷骰
- `Game.Core/Contracts/Sanguo/GameEvents.cs`：回合开始/结束/推进、存档、游戏结束
- `Game.Core/Contracts/Sanguo/PlayerAndAiEvents.cs`：玩家状态变化、AI 决策
- `Game.Core/Contracts/Sanguo/EconomyEvents.cs`：买城、付费、月结算、季度事件、年度地价

### 2.4 find_referencing_symbols：现有使用方式（测试/适配器）
- `RandomHelper` 当前仅在测试中使用：`Game.Core.Tests/Utilities/RandomHelperTests.cs`
  - `NextIntShouldReturnValueWithinRange`
  - `NextIntShouldProduceVariedResults`
  - `RandomHelperShouldBeThreadSafe`

- `SanguoDiceRolled` 当前仅在契约可实例化测试中出现：`Game.Core.Tests/Domain/SanguoContractInstantiationTests.cs`（`CanInstantiateBoardEvents`）。
  - 结论：现在“有契约但缺实现/缺发布路径”，Task 5 需要补齐“掷骰→发布事件→可测试捕获”的闭环。

- `IEventBus` 在 Core/Tests/Godot 适配层均有使用：
  - Core：`Game.Core/Engine/GameEngineCore.cs`、`Game.Core/Services/CombatService.cs`
  - Tests：多个 `CapturingEventBus : IEventBus`（用于断言事件内容）
  - Godot：`Game.Godot/Adapters/EventBusAdapter.cs`（Node + IEventBus）

## 3. 止损建议（实现 Task 5 时避免踩坑）
- 不要引入新的 RNG 库：优先复用 `RandomHelper.NextInt(1, 7)`；若需要确定性测试，再考虑通过“委托/接口注入”把随机源作为依赖注入（默认仍使用 `RandomHelper`）。
- 不要新增/复制事件契约：使用 `SanguoDiceRolled.EventType`（`core.sanguo.dice.rolled`）作为 `DomainEvent.Type`。
- `DomainEvent.Data` 用 `JsonElementEventData.FromObject(...)` 包装 payload，避免把任意对象塞进事件导致注入/反序列化风险（与 ADR-0004/安全口径一致）。
- 事件捕获测试建议复用既有模式：在测试里用 `CapturingEventBus` 收集 `DomainEvent`，断言 `Type` 和 `Data(Value)` 与掷骰点数一致。
