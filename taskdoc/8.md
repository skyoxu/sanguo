# 任务8：实现事件管理器（Serena 上下文准备）

生成时间：2025-12-18T14:30:41

## 任务映射与元数据
- tasks.json: `.taskmaster/tasks/tasks.json` -> `master.tasks[].id=8`
- tasks_back.json: `.taskmaster/tasks/tasks_back.json` -> `taskmaster_id=8`
- tasks_gameplay.json: `.taskmaster/tasks/tasks_gameplay.json` -> `taskmaster_id=8`

- 标题：实现事件管理器
- 状态：in-progress
- 依赖：7
- ADR 引用：ADR-0005, ADR-0015, ADR-0018, ADR-0020, ADR-0021, ADR-0024, ADR-0025
- 章节引用：CH01, CH04, CH05, CH06, CH07, CH09
- Overlay：docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md

### tasks_back 补充
- acceptance:
  - 核心玩法相关类与方法在 Game.Core 中实现且不依赖 Godot API。
  - 对应任务的 xUnit 测试用例存在并通过（见 test_refs 占位路径）。
  - 符合学习模块三（地产 / 租金 / 经济结算 / 环境事件）的设计：城池收益、过路费、季度环境事件与年度地价调整都由 Game.Core 统一结算，并在 UI 中有清晰可追踪的反馈。
  - Local demo references: C:\buildgame\godotdemo\dafuweng\monopoly_clone ; C:\buildgame\godotdemo\dafuweng\Prototype
  - 可选加固-审计追踪：记录出局事件与城池释放/转移；写入结构化审计日志 `logs/ci/<YYYY-MM-DD>/security-audit.jsonl`（字段至少 {ts, action, reason, target, caller}）。
  - 可选加固-事件溯源：对关键状态变更发布 `DomainEvent`（ADR-0004），并保留 CorrelationId/CausationId 以支持回放与排障。
  - 可选加固-资源限制：定义‘最大拥有城池数’上限（可配置），超限购买失败且记录审计/事件，避免状态膨胀与滥用。
- test_strategy:
  - 为核心玩法编写 xUnit + FluentAssertions 单元测试覆盖主要状态机与计算。
  - 使用覆盖率工具（coverlet）确保核心逻辑达到 ADR-0005 规定的门禁。
  - 在实现经济与事件系统之前，先对照 taskup.md 中的模块三说明，以及 Godot 演示项目中与资源产出 / 状态机相关的示例，编写覆盖月末结算、季度事件和年度调价的组合测试场景，确保数值变化与日志记录都可以在测试中被验证。
  - Local demo paths for implementation/tests: C:\buildgame\godotdemo\dafuweng\monopoly_clone ; C:\buildgame\godotdemo\dafuweng\Prototype
  - 加入 xUnit 用例：触发出局/城池释放/资金转移时，断言审计条目写入（可用内存 sink 或临时文件）且字段完整。
  - 加入 xUnit 用例：关键状态变更均发布 DomainEvent；校验事件 type/source/id/correlationId 以及顺序可回放。
  - 加入 xUnit 用例：当玩家拥有城池数达到上限时，购买被拒绝且状态不变，并写入审计条目。

### tasks_gameplay 补充
- acceptance:
  - 核心玩法相关类与方法在 Game.Core 中实现且不依赖 Godot API。
  - 对应任务的 xUnit 测试用例存在并通过（见 test_refs 占位路径）。
  - 符合学习模块三（地产 / 租金 / 经济结算 / 环境事件）的设计：城池收益、过路费、季度环境事件与年度地价调整都由 Game.Core 统一结算，并在 UI 中有清晰可追踪的反馈。
  - Local demo references: C:\buildgame\godotdemo\dafuweng\monopoly_clone ; C:\buildgame\godotdemo\dafuweng\Prototype
  - 可选加固-审计追踪：记录出局事件与城池释放/转移；写入结构化审计日志 `logs/ci/<YYYY-MM-DD>/security-audit.jsonl`（字段至少 {ts, action, reason, target, caller}）。
  - 可选加固-事件溯源：对关键状态变更发布 `DomainEvent`（ADR-0004），并保留 CorrelationId/CausationId 以支持回放与排障。
  - 可选加固-资源限制：定义‘最大拥有城池数’上限（可配置），超限购买失败且记录审计/事件，避免状态膨胀与滥用。
- test_strategy:
  - 为核心玩法编写 xUnit + FluentAssertions 单元测试覆盖主要状态机与计算。
  - 使用覆盖率工具（coverlet）确保核心逻辑达到 ADR-0005 规定的门禁。
  - 在实现经济与事件系统之前，先对照 taskup.md 中的模块三说明，以及 Godot 演示项目中与资源产出 / 状态机相关的示例，编写覆盖月末结算、季度事件和年度调价的组合测试场景，确保数值变化与日志记录都可以在测试中被验证。
  - Local demo paths for implementation/tests: C:\buildgame\godotdemo\dafuweng\monopoly_clone ; C:\buildgame\godotdemo\dafuweng\Prototype
  - 加入 xUnit 用例：触发出局/城池释放/资金转移时，断言审计条目写入（可用内存 sink 或临时文件）且字段完整。
  - 加入 xUnit 用例：关键状态变更均发布 DomainEvent；校验事件 type/source/id/correlationId 以及顺序可回放。
  - 加入 xUnit 用例：当玩家拥有城池数达到上限时，购买被拒绝且状态不变，并写入审计条目。

## 现有事件系统组件（find_symbol 结果摘要）
### DomainEvent (Game.Core/Contracts/DomainEvent.cs)
```csharp
public record DomainEvent(
    string Type,
    string Source,
    IEventData? Data,
    DateTime Timestamp,
    string Id,
    string SpecVersion = "1.0",
    string DataContentType = "application/json"
);
```

### IEventBus (Game.Core/Services/EventBus.cs)
```csharp
public interface IEventBus
{
    Task PublishAsync(DomainEvent evt);
    IDisposable Subscribe(Func<DomainEvent, Task> handler);
}
```

### InMemoryEventBus (Game.Core/Services/EventBus.cs)
```csharp
public class InMemoryEventBus : IEventBus
{
    public Task PublishAsync(DomainEvent evt)
    {
        List<Func<DomainEvent, Task>> snapshot;
        lock (_gate) snapshot = _handlers.ToList();
        return Task.WhenAll(snapshot.Select(h => SafeInvoke(h, evt)));
    }

    private async Task SafeInvoke(Func<DomainEvent, Task> h, DomainEvent evt)
    {
        try { await h(evt); }
        catch (Exception ex)
        {
            try { _logger?.Error($"Event handler failed (type={evt.Type} source={evt.Source} id={evt.Id})", ex); } catch { }
            try
            {
                var ctx = new Dictionary<string, string>
                {
                    ["event_type"] = evt.Type,
                    ["event_source"] = evt.Source,
                    ["event_id"] = evt.Id,
                    ["handler"] = h.Method.Name,
                    ["handler_type"] = h.Method.DeclaringType?.FullName ?? "unknown",
                };
                _reporter?.CaptureException("eventbus.handler.exception", ex, ctx);
            }
            catch { }
        }
    }
}
```

### NullEventBus (Game.Core/Services/NullEventBus.cs)
```csharp
public sealed class NullEventBus : IEventBus
{
    public static NullEventBus Instance { get; } = new();
    public Task PublishAsync(DomainEvent evt) => Task.CompletedTask;
    public IDisposable Subscribe(Func<DomainEvent, Task> handler) => NoopDisposable.Instance;
}
```

### JsonElementEventData (Game.Core/Contracts/JsonEventData.cs)
```csharp
public sealed record JsonElementEventData(JsonElement Value) : IEventData
{
    public static JsonElementEventData FromObject<T>(T value, JsonSerializerOptions? options = null)
        => new(JsonSerializer.SerializeToElement(value, options));
}
```

## 与 Godot 层的桥接（EventBusAdapter + CompositionRoot）
### EventBusAdapter (Game.Godot/Adapters/EventBusAdapter.cs)
```csharp
public partial class EventBusAdapter : Node, IEventBus
{
    [Signal]
    public delegate void DomainEventEmittedEventHandler(string type, string source, string dataJson, string id, string specVersion, string dataContentType, string timestampIso);

    public Task PublishAsync(DomainEvent evt)
    {
        var dataJson = evt.Data switch
        {
            null => "{}",
            RawJsonEventData raw => string.IsNullOrWhiteSpace(raw.Json) ? "{}" : raw.Json,
            JsonElementEventData element => element.Value.ValueKind == JsonValueKind.Undefined ? "{}" : element.Value.GetRawText(),
            _ => JsonSerializer.Serialize(evt.Data, JsonSerializeOptions),
        };
        EmitSignal(SignalName.DomainEventEmitted, evt.Type, evt.Source, dataJson, evt.Id, evt.SpecVersion, evt.DataContentType, evt.Timestamp.ToString("o"));
        return Task.WhenAll(snapshot.Select(h => SafeInvoke(h, evt)));
    }
}
```

### CompositionRoot (Game.Godot/Autoloads/CompositionRoot.cs)
```csharp
private void InitializePorts()
{
    var bus = RequireAutoload<Adapters.EventBusAdapter>("/root/EventBus", "EventBus");
    var sentry = RequireAutoload<SentryClient>("/root/SentryClient", "SentryClient");

    var reporter = new Adapters.ErrorReporterAdapter { Name = "ErrorReporter", Sentry = sentry };
    AddChild(reporter);

    EventBus = bus;
    bus.Logger = logger;
    bus.ErrorReporter = reporter;
}
```

## 关键事件契约（ADR-0004 type 命名规则）
- `Game.Core/Contracts/Sanguo/GameEvents.cs`: `core.sanguo.game.*`
- `Game.Core/Contracts/Sanguo/BoardEvents.cs`: `core.sanguo.board.*` + `core.sanguo.dice.*`
- `Game.Core/Contracts/Sanguo/EconomyEvents.cs`: `core.sanguo.economy.*` + `core.sanguo.city.*`
- `Game.Core/Contracts/Sanguo/PlayerAndAiEvents.cs`: `core.sanguo.player.*` + `core.sanguo.ai.*`

## 模式观察（find_referencing_symbols 结果摘要）
- IEventBus 已被多个 Core 服务注入使用：`SanguoDiceService`/`CombatService`/`SanguoTurnManager`/`SanguoEconomyManager`/`GameEngineCore`。
- Godot 端主要通过 `EventBusAdapter`（Autoload `/root/EventBus`）发布与监听，并通过 Signal `DomainEventEmitted` 给 UI。
- `CompositionRoot` 将 `EventBusAdapter` 赋值到 `IEventBus EventBus`，并注入 `Logger/ErrorReporter`，属于 fail-fast 装配。

## 对 Task 8 的止损约束（不写代码，只强调约束）
- 事件契约以 `Game.Core/Contracts/Sanguo/*.cs` 为准，Task 8 不允许新建契约文件；如不够，必须先停止并说明需新契约再继续。
- 先优先统一对齐：Core `IEventBus/InMemoryEventBus` + Godot `EventBusAdapter`（Signal bridge），避免出现第三套事件通道。
- payload 形式现状是混合（契约 record + 匿名对象）；Task 8 应该保持兼容两者，不要引入第三种 data 编码形式。

