# Task 4: 实现玩家类

## 0. 映射与来源
- Mapping: `tasks.json.master.tasks[].id` (`"4"`) <-> `tasks_back[].taskmaster_id` <-> `tasks_gameplay[].taskmaster_id`
- 注意：`tasks.json` 的 `id` 是字符串，views 文件里是数字，做关联时需 `str()` 归一化，否则会出现“找不到关联”的假报错。

## 1. 任务元信息（从三份任务文件汇总）
- tasks.json: title=`实现玩家类`, status=`pending`, priority=`high`, complexity=`5`
- tasks.json.details:
  - 扩展 Player 类，增加资金、当前位置和已拥有城池列表等属性，实现购买城池和支付过路费的方法，所有结算逻辑都在 Game.Core 层完成。在职责划分与输入处理上，可参考 Godot 官方演示项目 2d/kinematic_character、2d/platformer 中的角色控制器结构，采用类似的“数据在 Core、表现留在 Godot 场景”的分层思路。
- tasks.json.testStrategy:
  - 编写 xUnit 单元测试，验证玩家属性初始化、购买城池、支付过路费等方法在不同边界条件下的行为；通过构造多轮交易场景，确保资金与城池所有权变更符合 T2 PRD 中的经济规则。
- tasks.json.adrRefs=`['ADR-0005', 'ADR-0015', 'ADR-0018', 'ADR-0020', 'ADR-0021', 'ADR-0024', 'ADR-0025']`
- tasks.json.archRefs=`['CH01', 'CH04', 'CH05', 'CH06', 'CH07', 'CH09']`
- tasks.json.overlay=`docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md`
- tasks_back.json: layer=`core`, depends_on=`['SG-0003']`
  - adr_refs=`['ADR-0005', 'ADR-0015', 'ADR-0018', 'ADR-0020', 'ADR-0021', 'ADR-0024', 'ADR-0025']`
  - chapter_refs=`['CH01', 'CH04', 'CH05', 'CH06', 'CH07', 'CH09']`
  - overlay_refs=`['docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md']`
  - acceptance:
    - 核心玩法相关类与方法在 Game.Core 中实现且不依赖 Godot API。
    - 对应任务的 xUnit 测试用例存在并通过（见 test_refs 占位路径）。
  - test_strategy:
    - 为核心玩法编写 xUnit + FluentAssertions 单元测试覆盖主要状态机与计算。
    - 使用覆盖率工具（coverlet）确保核心逻辑达到 ADR-0005 规定的门禁。
- tasks_gameplay.json: layer=`core`, depends_on=`['GM-0003']`
  - adr_refs=`['ADR-0005', 'ADR-0015', 'ADR-0018', 'ADR-0020', 'ADR-0021', 'ADR-0024', 'ADR-0025']`
  - chapter_refs=`['CH01', 'CH04', 'CH05', 'CH06', 'CH07', 'CH09']`
  - overlay_refs=`['docs/architecture/overlays/PRD-SANGUO-T2/08/08-功能纵切-T2-三国大富翁闭环.md']`
  - acceptance:
    - 核心玩法相关类与方法在 Game.Core 中实现且不依赖 Godot API。
    - 对应任务的 xUnit 测试用例存在并通过（见 test_refs 占位路径）。
  - test_strategy:
    - 为核心玩法编写 xUnit + FluentAssertions 单元测试覆盖主要状态机与计算。
    - 使用覆盖率工具（coverlet）确保核心逻辑达到 ADR-0005 规定的门禁。

## 2. Serena 检索结果（为实现准备上下文）
### 2.1 find_symbol：现有 Player 实现与语义
- 当前 `Game.Core/Domain/Player.cs` 的 Player 语义偏“战斗/坐标移动”，包含 `Health` + `Position(X,Y)`，并提供 `Move(dx,dy)` 与 `TakeDamage(amount)`。
- 这与 Task 4 目标（资金/棋盘 index/已拥有城池）存在潜在语义冲突，落地前应明确：
  - 是否在原 Player 上扩展（高风险：会影响 CombatService 与既有测试）；
  - 或新增 `SanguoPlayer`/`SanguoPlayerState`（推荐：隔离“战斗 Player”和“大富翁 Player”）。
```csharp
public class Player
{
    public Health Health { get; private set; }
    public Position Position { get; private set; }

    public Player(int maxHealth = 100)
    {
        Health = new Health(maxHealth);
        Position = new Position(0, 0);
    }

    public void TakeDamage(int amount)
    {
        Health = Health.TakeDamage(amount);
    }

    public void Move(double dx, double dy)
    {
        Position = Position.Add(dx, dy);
    }

    public bool IsAlive => Health.IsAlive;
}
```

### 2.2 search_for_pattern：现有接口/端口（了解既有契约与分层方式）
- `IEventBus`：Core 层发布/订阅 DomainEvent 的统一入口
```csharp
public interface IEventBus
{
    Task PublishAsync(DomainEvent evt);
    IDisposable Subscribe(Func<DomainEvent, Task> handler);
}
```
- `DomainEvent`：CloudEvents 风格事件载体（ADR-0004 口径），后续买城/付费/状态变化建议通过它发布
```csharp
public record DomainEvent(
    string Type,
    string Source,
    IEventData? Data,
    DateTime Timestamp,
    string Id,
    string SpecVersion = "1.0",
    string DataContentType = "application/json"
);
```
- 现有 repository/port 接口（可作为后续“持久化玩家资产/城池所有权”的端口参考）：`IDataStore`、`ISaveGameRepository`、`IUserRepository`、`IInventoryRepository` 等。

### 2.3 find_symbol：事件契约（了解事件系统约定，参考 ADR-0004）
- 资金/位置变化（玩家视角）
```csharp
public sealed record SanguoPlayerStateChanged(
    string GameId,
    string PlayerId,
    decimal Money,
    int PositionIndex,
    System.DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.player.state.changed";
}
```
- 买城/付过路费（经济视角）
```csharp
public sealed record SanguoCityBought(
    string GameId,
    string BuyerId,
    string CityId,
    decimal Price,
    DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.city.bought";
}

public sealed record SanguoCityTollPaid(
    string GameId,
    string PayerId,
    string OwnerId,
    string CityId,
    decimal Amount,
    DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.city.toll.paid";
}
```
- 落点通常由移动事件触发（棋盘视角）
```csharp
public sealed record SanguoTokenMoved(
    string GameId,
    string PlayerId,
    int FromIndex,
    int ToIndex,
    int Steps,
    bool PassedStart,
    System.DateTimeOffset OccurredAt,
    string CorrelationId,
    string? CausationId
)
{
    /// <summary>
    /// CloudEvents type for this domain event.
    /// </summary>
    public const string EventType = "core.sanguo.board.token.moved";
}
```

### 2.4 find_referencing_symbols：依赖引用（了解已有模块如何使用）
- `Player` 被 `CombatService` 与 `Game.Core.Tests/Domain/PlayerTests.cs` 引用；因此“直接扩展现有 Player”会产生连锁影响（尤其是 Position/Move 语义）。
- `IEventBus` 在 `GameEngineCore`/`CombatService`/Godot `EventBusAdapter` 以及测试 `CapturingEventBus` 中使用；后续玩家买城/付费逻辑若要发事件，可沿用此范式。
- `SanguoPlayerStateChanged` / `SanguoCityBought` / `SanguoCityTollPaid` 当前没有业务引用点（Serena 查引用为空），说明它们是“先定契约、后落实现”的骨干；Task 4/后续任务应主动对齐并补齐对应单元测试。

## 3. 止损建议（实现前必须澄清）
- Task 4 写的是“扩展 Player 类”，但仓库现有 Player 更像战斗模型；建议在 tasks_back/tasks_gameplay 的 acceptance 中补一条：必须明确并记录“战斗 Player vs Sanguo Player”的职责边界，避免语义混用。
- 若决定新增 `SanguoPlayer`：建议最小字段集合与事件对齐：`PlayerId`（string）、`Money`（decimal）、`PositionIndex`（int）、`OwnedCityIds`（List<string>）。
- 买城/付费方法建议输出“显式结果”（例如 `bool success` + 金额变化），不要隐式吞错；并在测试中用边界值覆盖（余额不足、同一城重复购买、自己城市不付费等）。
