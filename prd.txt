T2阶段「最小可玩闭环」PRD文档
系统范围与目标

本项目是一款基于 Godot 4.x、使用 C# 开发的2D单机游戏，题材取自三国时期，玩法类似“大富翁”（Monopoly）。地图采用真实三国地理的“城池-州郡”结构，设计为环形单一路线（无分叉）。本文件定义T2阶段的最小可玩闭环，实现核心游戏循环和基础玩法。

范围：在该阶段，游戏包含玩家与至少一个AI对手，支持轮流掷骰前进、购买城池、收取过路费、定期结算收益及触发环境事件等核心机制。战斗、装备、道具、卡片等高级元素暂不引入，仅保留金钱和城池所有权作为主要变量。游戏为单机离线模式，平台限定为Windows（Godot Mono版本）


目标：实现完整的玩法闭环：玩家掷骰子→按点数移动→停留格子判断购买或付费→月末结算收益→季度环境事件→年初地价调整→下一轮循环。确保这一循环可以周而复始进行，形成基本的玩法体验。该阶段侧重验证核心机制，无明确胜负条件（可在后续阶段添加例如破产判负等规则）。

用户故事

掷骰前进：作为玩家，我希望每回合掷骰子移动我的棋子，以随机步数在地图城池间前进，体验不可预测的行军过程。

购地收租：作为玩家，当我的棋子停在一个无人占有的城池时，我希望能够购买该城池，将其纳入我的资产；当停在他人拥有的城池时，我需要支付过路费给拥有者，体现资源争夺与经营策略。

收益结算：作为玩家，我希望每月最后一天自动结算我所拥有城池的收益，使我的资金随着时间增长，增加经营管理的维度。

环境事件：作为玩家，我希望每季度开始时出现随机的环境事件影响某些区域（州郡）的土地收益，这会带来正负不定的效果，为游戏增加变化和策略性。

地价变动：作为玩家，我希望每年年初进行一次全国性的地价调整，使所有城池的价值发生变化，从而影响我未来的投资和资金策略。

轮流对抗：作为玩家，我希望能和AI对手轮流行动，看着AI也掷骰、走格、买地或付费，使游戏具有竞争性和挑战性。

功能模块

T2阶段的功能划分如下，每个模块对应游戏闭环中的关键功能点：

地图与城池管理

环形地图：地图由若干相邻的城池格组成，首尾相连形成环路（一条闭合的线路）。没有分叉路线，每前进一定步数必然按照固定顺序经过城池。

城池属性：每个城池有名称（可取三国时期真实城池名）、所属州郡（用于区域事件）、基础价格和基础过路费。初始时所有城池无人占有。环形地图的数据结构可以使用列表维护城池顺序，并支持根据玩家当前位置和骰子点数计算新的位置（越过列表末尾则从头部继续，形成环）。

州郡结构：城池按历史上的州/郡划分区域，每个城池记录所属的州郡名称。季度环境事件将以此为单位影响区域内城池的收益。

玩家与棋子

玩家与AI：游戏至少包含1名人类玩家和1名AI玩家（可扩展为多人但本阶段至少一对一）。玩家和AI轮流行动，每人行动消耗1天游戏内时间。

属性：玩家拥有资金（金钱）、当前位置（所在城池索引）和已拥有的城池列表等属性。初始每位玩家有一定的起始资金（例如统一设定起始金钱）。

棋子表示：每个玩家在地图上对应一个棋子（如头像或旗帜），用于在地图上展示当前位置。棋子的移动由掷骰结果决定。

AI行为：AI按照与玩家相同的规则行动。AI策略在本阶段可简化实现：例如，每当AI掷骰移动后，若停留的城池无人占有且AI有足够资金则购买，否则略过；若需支付过路费则自动扣款。AI不需要复杂决策，保证闭环运行即可。

掷骰与移动

骰子机制：每个回合开始时，由当前行动者掷骰子一次。骰子为标准六面骰（点数1~6随机）。可以通过UI按钮由玩家点击掷骰，AI则自动随机掷骰。掷骰结果决定棋子前进步数。

棋子移动：根据骰子点数，玩家/AI的棋子沿环形路线顺序前进相应数量的城池格。移动可以逐格展示，也可以直接跳至目标格。若走到终点则绕回起点继续余下步数。移动完成后，棋子停留在新的城池上，触发该格的后续动作。

土地购买与过路费

购买城池：当棋子停留在一个无人拥有的城池时，当前玩家可以选择购买该城池。购买花费等于城池的当前价格（初始为基础价格，可能受地价调整影响）。购买后，从玩家资金中扣除费用，该城池的所属权归该玩家所有。之后其他玩家每次经过或停留在此城池都需支付过路费给拥有者。

过路费：当棋子停留在他人拥有的城池时，当前玩家需向城池所有者支付过路费。过路费金额可设定为城池当前价格的一定比例（例如50%）或直接使用城池的基础过路费（可随地价调整而变化）。支付后从当前玩家资金扣除，相应金额增加到所有者资金中。如果玩家资金不足支付全额，可在本阶段简单处理为支付所有剩余资金（后续阶段可引入破产判定）。

跳过/自有：如果棋子停留的城池已经是该玩家自己所有，则无须进行任何购买或付费动作，直接结束该步。玩家也可以在有权购买时放弃购买（则城池仍无主，留待以后他人经过时再次触发购买机会）。

经济与月末结算

资金与收益：玩家资金会因为购地支出、支付过路费而减少，因收取他人过路费、月末收益而增加。需要实时更新玩家的资金值，并在UI上展示。

月末结算：游戏时间以“天”为单位推进，每经过一天需要检查是否月末。每月最后一天结束后，触发一次产业产出结算：计算每位玩家在该月从其拥有的所有城池的产业类建筑所获得的收益（其他类型建筑没有月度结算收益），并将收益累加到玩家资金中。收益计算方式可简单设定为每座城池每月固定产生一定金额（例如按照城池基础价格的一定比例作为月收益），受环境事件影响时按调整后的比例计算。月末结算在当月最后一个回合执行完毕后自动进行，无需玩家操作。结算过程和结果可通过日志或UI提示告知玩家。

季度环境事件

事件触发：每当进入新的季度（即游戏内时间的1月1日、4月1日、7月1日或10月1日）时，可能触发一次环境事件。可设定一定的随机概率决定该季度是否出现事件（例如50%几率）。若触发，则随机选择一个州或郡，以及该事件的效果类型。

事件类型：事件效果针对所选区域内的全部城池，调整其经济收益。例如：

丰收：该区域当季（该季度内）所有城池的月末收益提升（例如提升+50%）。

灾害：该区域当季所有城池的月末收益降低（例如减产-50%）。

政令：影响土地交易或费用的事件，例如“本季度内某区域暂停土地买卖”或“过路费翻倍/减半”等（T2阶段可仅实现产出增减，复杂效果留待以后）。

持续与复原：环境事件的效果在该季度内持续，影响当季（月末）收益或相关费用。到下季度开始时效果自动结束（新的季度可能产生新的事件替代旧效果）。需要在系统中对受影响区域做标记，在收益结算和收费计算时应用修正系数。

信息提示：当事件触发时，应通过UI通知玩家事件内容（例如弹出消息：“发生干旱！荆州本季度粮产减半”），以便玩家调整策略。未触发事件的季度，可略过不提示。

年度地价调整

触发时机：每当进入新的一年（游戏时间的1月1日，即每第12月结束后）年初，执行一次全国性的地价调整。这表示所有城池的基础价格和基础过路费发生变化。

调整规则：地价调整可采用随机或预设的规则，例如：

随机涨跌：为模拟经济波动，每年的地价在总体上随机上浮或下调一定比例（例如±10%），然后应用到所有城池的价格和过路费上。不同区域也可有差异，但T2阶段可统一处理。

固定增长：或设定每年所有城池价格固定上涨一定比例，模拟通货膨胀和地价上涨趋势。

影响：地价调整会直接影响未购买城池的购买价格，以及过路费和月收益（若这些与价格相关）。已被玩家拥有的城池，其价值变化不会影响已支付的购买成本，但后续若实现资产评估或出售则用新价格。T2阶段主要作用是动态调整难度和财富增长速度。

信息提示：年初调整时，通过UI向玩家提示总体地价变化趋势（例如“新年伊始，全国地价上涨10%”）。调整应在所有月末结算和季度事件处理完之后进行，再开始新一年的第1天。

回合与时间管理

回合顺序：游戏按照回合制进行，以“天”为最小时间单位。每个回合代表一天，由所有玩家（人类玩家和AI）交替轮流行动。即：回合开始→玩家A行动→玩家B行动→回合结束，以此循环。轮替顺序在游戏开始时固定（例如玩家先手，然后AI），除非后续设计加入特殊规则改变顺序。

时间推进：需要有一个全局的时间跟踪，包括当前的日、月、年。初始可设定为第1年1月1日。每执行完一次所有玩家的回合，天数增加1，更新日期。若天数超出当前月天数，则重置为1并月份+1；若月份超过12则重置为1并年份+1。为了简化，可将每月视为固定30天处理。

事件检查：在每个回合结束后，根据更新后的日期检查是否有特殊事件触发：

月末：如果刚结束的这一天是该月最后一天，则执行月末收益结算。

季度首日：如果新的日期是1月1日、4月1日、7月1日或10月1日，则进入新的季度，按概率触发环境事件。

年初：如果新的日期是1月1日且年份变化，则执行年初地价调整（然后同样按季度规则处理Q1的环境事件）。

执行次序：当年初与季度重合时（1月1日），应先执行地价调整，再执行该季度的环境事件，以免事件影响前后不一致；月末结算总是在月最后一天当晚进行（在日期推进到下月之前）。时间管理模块确保以上事件按顺序触发。

回合循环：在处理完当前回合的一切事务（包括上述时间事件）后，游戏进入下一回合，如此循环往复，直到出现游戏终局条件（T2阶段暂未定义终局，可无限循环）。

回合机制详述

每个游戏日（回合）的具体流程如下：

开始回合：触发或结算回合开始阶段的事件，确定当前回合的首个行动玩家。

玩家回合开始：如果是人类玩家，则等待玩家输入（掷骰）；如果是AI则自动执行。

玩家其他行动：T2不实装，留空阶段

掷骰：当前玩家进行一次骰子投掷，得到1~6的随机点数。

棋子移动：根据骰子点数移动玩家棋子沿地图前进相应步数，抵达新的城池格。移动过程中可以逐步显示棋子经过的城池，最终停留在目标城池。

格子事件：根据棋子停留的城池状态执行相应操作：

无人城池：若该城池没有主人，当前玩家可选择购买。若购买，则扣除资金并将城池登记到其名下；若放弃，保持无人状态。

他人城池：若该城池已有其他玩家占有，当前玩家需支付过路费给拥有者。根据城池当前价计算费用，扣款转入对方账户。如果资金不足，扣除全部剩余资金（后续可扩展破产逻辑）。

己方城池：若城池为当前玩家所有，则无特殊操作，等同安全地点。

玩家回合结束：掷骰及相关城池事件结算结束则玩家回合自动结束，锁定玩家当前属性及状态，开启下一个玩家的当前回合开始阶段，所有玩家当前回合结束后进入当前游戏日回合结束阶段

当前游戏日回合结束：当前回合所有玩家行动结束，执行以下时序更新和检查：

将游戏时间推进1天（更新日历日期：日+1，必要时进位月份/年份）。

检查是否触发月末结算：如果刚才这天是月末（如30日或31日等），则计算所有玩家当月产业收益并结算给各自资金。

检查是否触发季度事件：如果新日期处于新的季度开始（如1日且月份为1、4、7、10月），按概率决定是否触发环境事件并应用其效果。

检查是否触发年初调整：如果新日期为1月1日（新年），执行全国地价调整，调整所有城池价格和收益基准。地价调整应在季度事件之前执行（当两者为同一天）。

下一回合：重复以上步骤，持续进行回合循环。

通过上述顺序，确保游戏的核心闭环完整运行：掷骰前进 -> 买地/付费 -> 收益结算/事件 -> 下个玩家。该机制在后台由回合管理器自动执行，使游戏日历不断推进，经济和资源随时间演进。

时间推进规则详述

游戏采用离散时间步进模型，将时间划分为日、月、年，并通过回合驱动时间前进。具体规则如下：

日（日循环）：每个回合等于一天，游戏从1日开始计时。回合结束时天数+1。为了简单，月份天数可固定为30天（或采用实际月份天数表）。当天数超过当月最大天数时，重置为1日并月数+1。

月（月循环）：月份从1增至12（代表一月至十二月）。当月份超过12时，重置为1月并年份+1。每月最后一天（例如第30日）被视为月末，触发一次收益结算，将该月玩家所拥有土地的产出收益发放。收益计算可按城池固定值或价格比例。结算后将产出归零，进入新月。

季度：将一年划分为4个季度：Q1（1-3月）、Q2（4-6月）、Q3（7-9月）、Q4（10-12月）。当进入4月1日、7月1日、10月1日、（以及1月1日作为新年）时，即进入新季度的第一天。在这些天，会以预设概率触发环境事件。若触发，则该事件在接下来的三个月内有效，影响对应区域的收益/费用。每季度最多触发一次事件，未触发则本季度无特殊事件影响。

年度：年份每经过12个月增加1。每当进入新年的1月1日时，执行年初地价调整。地价调整适用于全局，立即更新所有城池的价格和相关经济参数。调整完毕后，该年新的经济基准确定。若年初也是季度开始（Q1），则随后按照季度流程判断是否有环境事件。

同步与优先级：月末结算、季度事件、年初调整的顺序由时间点决定，不会同时发生冲突：

月末结算在上月最后一日结束时触发。

季度事件在特定季度首日早晨触发（年初也作为季度首日）。

年初调整在年首日与季度事件同日时优先执行，然后再处理季度事件。

时间显示：游戏界面上应显示当前的日期（年/月/日），方便玩家直观了解距离下次事件的时间。例如：“第2年5月14日”。这有助于玩家规划，例如月底前筹措资金等。

通过严格的时间推进规则，游戏将模拟经营过程中的周期性事件，形成节奏鲜明的循环：每天行动带来即时效果，每月、每季、每年又有固定事件，使玩家短期决策与长期策略相结合。

系统架构设计
系统上下文

本游戏为离线单机系统，主要交互在本地进行。上下文包括：玩家作为操作者，通过键鼠输入和UI界面与游戏交互；游戏运行于Godot引擎环境内，无外部服务器依赖。系统边界上，唯一的外部接口是本地文件系统用于存取存档（进度保存），以及操作系统窗口/音频等平台服务。整个应用封装为Windows桌面程序（EXE），不涉及网络通信。

模块分层（C4容器视图）

按照ARC42/C4的方法，系统采用分层的模块化架构，将游戏逻辑与引擎表现解耦。主要容器/子系统包括：

游戏核心逻辑 (Game.Core)：
纯C#实现的领域层，包含游戏规则和数据模型。例如玩家、城池、地图、资金结算等核心类都在该层定义。核心逻辑不依赖Godot引擎，可独立测试。

Godot表现层 (Game.Godot)：
Godot引擎相关部分，包含场景(Node)树、UI界面、输入控制和音效等。该层通过调用Game.Core提供的接口来实现具体显示和交互，例如根据核心计算的结果更新棋子位置、资金显示等。

事件与系统服务：通过Godot的单例Autoload提供全局服务模块，如事件总线(EventBus)、数据存储(DataStore)、时间/计时服务等
。事件总线用于在核心逻辑和Godot节点之间解耦消息传递。例如，核心层完成一次结算后，可发布事件通知UI更新。DataStore用于存档保存/读取，时间服务可用于调度AI延迟行动等。这些服务模块作为应用内的“基础设施”，在Godot启动时加载。

存储容器：使用本地文件系统保存游戏进度（GameState）。Game.Core提供GameState数据结构，Game.Godot层通过IDataStore接口调用存储服务，将GameState序列化为文件（JSON等）保存到user://目录。由于T2阶段主要关注玩法闭环，可暂不详细设计存档格式，但框架支持已在模板中实现。

上述容器均运行于同一进程内，通过方法调用或事件总线通信。例如，Godot层捕获到玩家点击“掷骰”按钮事件，调用核心层的掷骰方法获取结果，然后根据结果移动Godot层的棋子节点；当核心层检测到月末结算完成，会通过EventBus发布“MonthEndSettled”事件，由UI监听显示收益信息。

主要组件与类设计（C4组件视图）

根据功能模块划分，核心逻辑将由以下主要类和结构组成：

Board（或GameMap）：表示游戏棋盘/地图。内部包含一个有序列表List<City>存放环形路线上的所有城池。提供根据当前位置和骰子步数计算新位置的方法（考虑环绕）。Board可加载初始城池数据（名称、所属州郡、基础价等），这些数据可硬编码或从配置文件读取。

City（城池）：表示地图上的一个城池节点，包含属性：Name 名称，Region 所属州/郡，BasePrice 基础价格，BaseToll 基础过路费，Owner 当前拥有者（引用Player对象或null），BaseYield 月产值（可基于价格或独立设置）。还可包含计算当前价格/过路费的方法（考虑地价调整因素，例如City可以有CurrentPrice和CurrentToll实时值）。

Player（玩家）：表示一个玩家（人或AI），属性有：Name 名称/标识，Money 当前资金，Position 当前所在城池索引或引用，OwnedCities 已拥有城池集合。模板中已有基本Player类，将扩展其属性以满足本玩法需要（增加Money等）。例如，Player初始资金在GameConfig或GameState中设定，Player对象跟踪资金变动和位置移动。
此外可增加方法如PurchaseCity(City)、PayRent(amount)等操作资金和资产。

Dice（骰子）：可以不需独立类，只用函数或方法在需要时生成随机数1-6。若设计为类则包含方法Roll()返回点数，内部利用随机数生成器。Dice逻辑也可以由Godot引擎的RandomNumberGenerator实现，封装在Game.Godot层调用。

TurnManager（回合管理器）：负责控制回合顺序和时间推进的核心组件。可以实现为一个单例管理类，维护当前日期（年/月/日）和当前行动玩家索引。提供方法如NextTurn()，执行：确定当前玩家 -> 等待/调用掷骰 -> 调用Board移动棋子 -> 调用City处理购买或收费 -> 根据结果更新玩家状态 -> 然后调用AdvanceDay()推进日期并检查事件。内部的AdvanceDay()负责上述时间规则：判断月末、季度、年初并触发对应逻辑。TurnManager确保按照先后顺序执行月末结算、地价调整、环境事件，再切换下一个玩家。

EconomyManager（经济结算管理）：可选的独立管理器，用于处理周期结算和经济变动。如果逻辑简单也可由TurnManager直接实现。其职责包括：计算月末每玩家收益（遍历玩家OwnedCities累加产出），处理地价调整（更新所有City的价格相关属性），应用环境事件效果（例如在事件激活时给相关City打标记或调整其产出系数）。EconomyManager也可发布诸如“MonthlySettled”、“PriceAdjusted”、“EventOccurred”等事件供UI层响应。

EventManager（事件管理）：负责生成和管理季度环境事件。可在每个季度初由TurnManager调用，如EventManager.TryTriggerQuarterEvent(currentQuarter). 内部定义若干事件类型和对应逻辑，比如选取随机Region和随机事件效果，将效果存储（例如在一个结构中存当前有效的区域效果列表）。在收益结算或费用计算时，EventManager提供接口查询某城池是否受事件影响及调整系数。事件在下一季度自动失效，可通过记录事件的持续季度来比较清除过期事件。

上述核心组件多作为Game.Core中的普通C#类处理游戏状态。GameState（游戏状态记录）将包含关键数据快照，如当前日期、所有玩家状态（资金、位置、资产）、城池所属关系等，用于存档和回溯。模板提供的GameState record可扩展这些字段

。GameStateManager利用该结构进行保存/加载。

在Godot引擎（Game.Godot层），将有对应的节点和脚本与核心类配合工作：

Main场景：作为游戏入口场景，包含基本节点结构和导航控制。根据模板，Main.tscn加载ScreenRoot和ScreenNavigator等。游戏主循环可以在Main或专门的GameScreen中运行。建议创建GameScreen场景（或称BoardScreen）用于游戏主屏幕，展示地图和处理回合逻辑。ScreenNavigator可用于在菜单/游戏屏幕间切换。

地图与城池节点：GameScreen场景下，使用Node2D或Control节点构建地图UI。每个城池可以对应一个节点（例如Sprite或Button显示城池位置和名称）。这些城池节点可以从Board数据初始化放置在对应坐标。由于地图是环状单线，可在编辑器手动排列城池，也可按数据坐标布局。城池节点需要能表现不同状态（未占领/己方/敌方），可通过颜色或标记区分。

玩家棋子节点：为每个玩家在GameScreen上添加一个Sprite（或带动画的角色小图标）表示棋子。棋子通过Tweens或插值移动到目标城池节点的位置。玩家1和AI的棋子用不同外观区分。移动完成后，可以调用核心逻辑继续处理事件。

UI界面：包括显示当前玩家姓名、资金、当前日期的面板；骰子按钮和骰子结果显示；事件/通知显示框等。例如，界面上有“掷骰”按钮（仅在轮到人类玩家时激活），玩家点击后触发骰子动画和结果；结果可以文字显示“掷出了5点”。当有环境事件或地价调整发生时，UI弹出消息提示。当月末结算时，UI可以简报各玩家收入变化。资金和拥有土地列表也可在界面上展示或通过信息面板查看。

节点脚本与信号：Godot节点通过GDScript/C#脚本与核心逻辑交互。例如，骰子按钮的脚本调用Dice.Roll()获取点数，再把结果传给TurnManager处理移动。移动完成后，通过信号通知UI更新位置。如果城池可购买，UI弹出询问对话框让玩家确认购买（是/否按钮）；玩家选择后，再调用核心Player.PurchaseCity逻辑并更新UI（城池节点颜色变更、玩家资金减少）。使用Godot信号或EventBus在关键动作发生时进行通知和UI更新解耦。例如，EconomyManager完成月末收益计算后，通过EventBus发送事件，GameScreen的脚本收到信号后更新玩家资金显示并弹出“XX收到收益Y金币”的消息。

为了与现有项目结构兼容，我们尽量复用和扩展既有模块和命名。

 例如，领域模型将新增“三国”特有类如City，但仍遵循Game.Core下Domain的分类；Godot层新增GameScreen场景及对应Autoload控制逻辑（如一个GameController脚本作为Autoload，用于管理回合和事件），符合模板建议为核心场景设计专用Autoload的思路

。测试方面，可为关键流程编写xUnit测试（针对核心逻辑，如回合推进、经济计算）和GdUnit4测试（针对场景交互，如掷骰后棋子正确移动）。

总结与下一步

通过以上架构与设计，T2阶段将实现“三国大富翁”游戏的最小可玩闭环：玩家和AI通过掷骰在三国地图上竞争土地，收取租金并体验经济事件。设计重点强调完整性和循环，确保游戏可以无尽运转并反馈结果。该PRD文档内容清晰划分模块，方便后续由项目管理工具（tasks master MCP）进一步分解为具体开发任务，由自动化代码代理（superclaude）生成相应代码实现。同时，架构设计与现有仓库模板保持一致，在冲突情况下以现有结构优先，确保新功能无缝融入当前项目框架

。下一步工作将基于此PRD拆解任务，逐一完成各模块的开发与测试，最终使游戏具备基本的可玩性闭环。